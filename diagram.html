<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Selah - Diagram</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  ::-webkit-scrollbar { display: none; width: 0; background: transparent; }
  * { -ms-overflow-style: none; scrollbar-width: none; }

  :root {
    --bg: #F5F2EB;
    --text-dark: #321201;
    --text-muted: #8C7B6E;
    
    /* Graph Colors */
    --node-primary: #321201;     /* Dark brown */
    --node-secondary: #707560;   /* Muted green */
    --node-action: #F2A900;      /* Yellow action lever */
    --link-color: #E2DFD8;       /* Faint lines */
  }

  html, body {
    height: 100%;
    background: var(--bg);
    background-image: 
      linear-gradient(rgba(0,0,0,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px);
    background-size: 30px 30px;
    font-family: 'Inter', sans-serif;
    color: var(--text-dark);
    overflow: hidden;
  }

  /* ── NAV ── */
  nav {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 20px 48px;
    background: var(--bg);
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 100;
    border-bottom: 1px solid rgba(0,0,0,0.04);
  }

  .logo {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 19px;
    font-weight: 400;
    color: var(--text-dark);
    text-decoration: none;
  }
  .logo img { width: 36px; height: 36px; object-fit: contain; mix-blend-mode: multiply; }

  .nav-right {
    display: flex;
    align-items: center;
    gap: 32px;
  }

  /* ── SYNC BUTTON ── */
  .sync-btn {
    background: var(--text-dark);
    color: white;
    border: none;
    border-radius: 100px;
    padding: 8px 20px;
    font-size: 13px;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  .sync-btn:hover { opacity: 0.85; }

  .nav-links { display: flex; gap: 32px; list-style: none; }
  .nav-links a {
    font-size: 15px; font-weight: 400; color: var(--text-dark);
    text-decoration: none; opacity: 0.85; transition: opacity 0.15s;
  }
  .nav-links a:hover, .nav-links a.active { opacity: 1; font-weight: 500; }

  /* ── DIAGRAM CANVAS ── */
  #diagram-container {
    width: 100vw;
    height: 100vh;
    padding-top: 80px;
    position: relative;
    cursor: grab;
  }
  #diagram-container:active { cursor: grabbing; }

  /* ── LOADING STATE ── */
  #loader {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    text-align: center;
  }
  #loader img {
    width: 48px; height: 48px;
    animation: spin 4s linear infinite;
    mix-blend-mode: multiply;
  }
  #loader p { font-size: 15px; color: var(--text-muted); }
  @keyframes spin { 100% { transform: rotate(360deg); } }
</style>
</head>
<body>

<nav>
  <div class="nav-left">
    <a class="logo" href="landingPage.html">
      <img src="logo" alt="Selah Logo">
      Selah
    </a>
  </div>
  <div class="nav-right">
    <button class="sync-btn" id="sync-btn" onclick="syncToVault()">Commit to Vault</button>
    <ul class="nav-links">
      <li><a href="#">Semantic (Plugins)</a></li>
      <li><a href="#" class="active">Diagram</a></li>
      <li><a href="#">Notes</a></li>
      <li><a href="#">About</a></li>
    </ul>
  </div>
</nav>

<div id="diagram-container">
  <div id="loader">
    <img src="logo" alt="Loading">
    <p>Synthesizing neural map...</p>
  </div>
</div>

<script>
  const loader = document.getElementById('loader');
  const container = document.getElementById('diagram-container');
  
  // State variable to hold data for syncing
  let currentGraphData = null; 

  async function fetchChatHistory() {
    try {
      const db = JSON.parse(localStorage.getItem('selah_memory'));
      if (!db || !db.activeChatId) return [];
      
      const chat = db.chats.find(c => c.id === db.activeChatId);
      return chat && chat.messages ? chat.messages : [];
    } catch (e) {
      console.error("Failed to load history from local memory", e);
      return [];
    }
  }

  async function generateGraphData() {
    const chatHistory = await fetchChatHistory();

    if (chatHistory.length === 0) {
      loader.innerHTML = "<p style='color: var(--text-dark);'>No chat history found. Go back and talk to Selah first.</p>";
      return;
    }

    let conversationText = chatHistory.map(msg => `${msg.role.toUpperCase()}: ${msg.content}`).join('\n');

    // ── UPGRADED HUB & WEB PROMPT ──
    const systemPrompt = `You are a master psychological mapper. Analyze the chat and create a highly INTERCONNECTED mind map.

    CRITICAL RULES:
    1. SPELL CHECK: Ensure perfect spelling.
    2. NO LINEAR CHAINS: Do NOT create a single straight line (A -> B -> C -> D). You must create a complex NETWORK.
    3. CREATE HUBS: The 'self' node (the user) or the main 'problem' must be a central HUB with MULTIPLE lines branching out to different nodes. 
    4. CROSS-LINK: Connect nodes to each other. For example, a 'problem' can connect to another 'problem', and both can connect to the 'self'.

    GROUPS: 'self', 'problem', 'insight', 'desire', 'action'

    OUTPUT VALID JSON EXACTLY LIKE THIS:
    {
      "nodes": [
        {"id": "Short Name", "group": "self" | "problem" | "insight" | "desire" | "action"}
      ],
      "links": [
        {"source": "Concept 1", "target": "Concept 2", "relation": "battles" | "yearns for" | "has" | "amplifies"}
      ]
    }
    Rules: Keep node names very short (1-3 words). DO NOT USE MARKDOWN.`;

    try {
      const response = await fetch('http://localhost:11434/api/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'llama3.2:1b', 
          prompt: conversationText,
          system: systemPrompt,
          stream: false,
          format: 'json', 
          options: { temperature: 0.1, num_predict: 1000 } 
        })
      });

      if (!response.ok) throw new Error('Ollama connection failed');

      const data = await response.json();
      let cleanJSONText = data.response.replace(/```json/gi, '').replace(/```/g, '').trim();
      const graphJSON = JSON.parse(cleanJSONText);
      
      if (!graphJSON.nodes || !graphJSON.links || graphJSON.nodes.length === 0) {
          throw new Error("AI generated an empty map.");
      }
      
      // Save data globally so the Sync button can use it
      currentGraphData = graphJSON;

      loader.style.display = 'none';
      drawGraph(graphJSON);

    } catch (error) {
      console.error("AI Mapping failed:", error);
      loader.innerHTML = `
        <p style="color: #321201;">Error synthesizing map. Check console.</p>
        <p style="font-size: 13px; opacity: 0.6; margin-top: 8px;">(The AI choked. Try refreshing!)</p>
      `;
    }
  }

  // ── SYNC TO LOCAL OBSIDIAN VAULT ──
  async function syncToVault() {
    if (!currentGraphData) {
      alert("No diagram data found to sync.");
      return;
    }

    const syncBtn = document.getElementById('sync-btn');
    const originalText = syncBtn.textContent;
    syncBtn.textContent = "Syncing...";

    try {
      // Loop through every node and create a markdown file for it
      for (const node of currentGraphData.nodes) {
        // Find all links connected to THIS specific node
        const relatedLinks = currentGraphData.links
          .filter(l => l.source === node.id || l.target === node.id || l.source.id === node.id || l.target.id === node.id)
          .map(l => {
            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
            return sourceId === node.id ? targetId : sourceId;
          });

        // Send the data to your bridge.js server
        await fetch('http://localhost:4000/save-note', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: node.id,
            content: `Dissected concept from Selahe.\n\nType: ${node.group.toUpperCase()}`,
            links: relatedLinks
          })
        });
      }

      syncBtn.textContent = "Vault Synced!";
      setTimeout(() => syncBtn.textContent = originalText, 2000);

    } catch (error) {
      console.error("Sync failed:", error);
      syncBtn.textContent = "Sync Failed";
      alert("Make sure your bridge.js server is running in the terminal!");
    }
  }

  function drawGraph(graph) {
    const width = window.innerWidth;
    const height = window.innerHeight;

    d3.select("#diagram-container").selectAll("svg").remove();

    const svg = d3.select("#diagram-container").append("svg")
      .attr("width", width).attr("height", height)
      .call(d3.zoom().scaleExtent([0.5, 4]).on("zoom", (event) => g.attr("transform", event.transform)));

    const g = svg.append("g");

    const simulation = d3.forceSimulation(graph.nodes)
      .force("link", d3.forceLink(graph.links).id(d => d.id).distance(160)) 
      .force("charge", d3.forceManyBody().strength(-400))
      .force("collide", d3.forceCollide().radius(40))
      .force("center", d3.forceCenter(width / 2, height / 2));

    // Draw the lines
    const link = g.append("g").selectAll("line").data(graph.links).join("line")
      .attr("stroke", "var(--link-color)").attr("stroke-width", 1.5).attr("stroke-opacity", 0.6);

    // Draw relationship text on the lines
    const linkLabels = g.append("g").selectAll("text").data(graph.links).join("text")
      .text(d => d.relation || "")
      .attr("font-family", "Inter, sans-serif")
      .attr("font-size", "9px")
      .attr("fill", "var(--text-muted)")
      .attr("text-anchor", "middle")
      .style("pointer-events", "none");

    const nodeGroup = g.append("g").selectAll("g").data(graph.nodes).join("g").call(drag(simulation));

    const getNodeColor = (group) => {
      if (group === 'action') return "var(--node-action)"; 
      return "var(--node-primary)"; 
    };

    const getNodeSize = (group) => group === 'action' ? 10 : 6;

    const circles = nodeGroup.append("circle")
      .attr("r", d => getNodeSize(d.group)).attr("fill", d => getNodeColor(d.group))
      .attr("stroke", "#F5F2EB").attr("stroke-width", 1.5).style("cursor", "pointer");

    const labels = nodeGroup.append("text").text(d => d.id)
      .attr("x", 12).attr("y", 4).style("font-family", "Inter, sans-serif")
      .style("font-size", "12px").style("fill", "var(--text-dark)")
      .style("pointer-events", "none");

    const linkedByIndex = {};
    graph.links.forEach(d => {
      linkedByIndex[`${d.source.index},${d.target.index}`] = 1;
      linkedByIndex[`${d.target.index},${d.source.index}`] = 1;
    });
    function isConnected(a, b) { return linkedByIndex[`${a.index},${b.index}`] || a.index === b.index; }

    nodeGroup.on("mouseover", function(event, d) {
      circles.transition().duration(200).style("opacity", o => isConnected(d, o) ? 1 : 0.1);
      link.transition().duration(200).style("opacity", o => (o.source === d || o.target === d ? 1 : 0.05))
          .attr("stroke", o => (o.source === d || o.target === d ? "var(--node-primary)" : "var(--link-color)"));
      
      linkLabels.transition().duration(200).style("opacity", o => (o.source === d || o.target === d ? 1 : 0.05))
          .attr("fill", o => (o.source === d || o.target === d ? "var(--node-primary)" : "var(--text-muted)"));

      d3.select(this).select("circle").transition().duration(200).attr("r", getNodeSize(d.group) * 1.5);
    }).on("mouseout", function(event, d) {
      circles.transition().duration(200).style("opacity", 1);
      link.transition().duration(200).style("opacity", 0.6).attr("stroke", "var(--link-color)");
      linkLabels.transition().duration(200).style("opacity", 1).attr("fill", "var(--text-muted)");
      d3.select(this).select("circle").transition().duration(200).attr("r", getNodeSize(d.group));
    });

    simulation.on("tick", () => {
      link.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
      linkLabels.attr("x", d => (d.source.x + d.target.x) / 2).attr("y", d => (d.source.y + d.target.y) / 2);
      nodeGroup.attr("transform", d => `translate(${d.x},${d.y})`);
    });

    function drag(simulation) {
      function dragstarted(event) { if (!event.active) simulation.alphaTarget(0.3).restart(); event.subject.fx = event.subject.x; event.subject.fy = event.subject.y; }
      function dragged(event) { event.subject.fx = event.x; event.subject.fy = event.y; }
      function dragended(event) { if (!event.active) simulation.alphaTarget(0); event.subject.fx = null; event.subject.fy = null; }
      return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
    }
  }

  generateGraphData();
</script>
</body>
</html>